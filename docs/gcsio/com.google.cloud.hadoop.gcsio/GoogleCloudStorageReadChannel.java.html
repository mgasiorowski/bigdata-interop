<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>GoogleCloudStorageReadChannel.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">coverage</a> &gt; <a href="../index.html" class="el_bundle">gcsio</a> &gt; <a href="index.source.html" class="el_package">com.google.cloud.hadoop.gcsio</a> &gt; <span class="el_source">GoogleCloudStorageReadChannel.java</span></div><h1>GoogleCloudStorageReadChannel.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.cloud.hadoop.gcsio;

import static com.google.cloud.hadoop.gcsio.GoogleCloudStorageImpl.createItemInfoForStorageObject;
import static com.google.cloud.hadoop.gcsio.StorageResourceId.createReadableString;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;
import static com.google.common.base.Strings.nullToEmpty;

import com.google.api.client.http.HttpHeaders;
import com.google.api.client.http.HttpResponse;
import com.google.api.client.util.BackOff;
import com.google.api.client.util.BackOffUtils;
import com.google.api.client.util.ExponentialBackOff;
import com.google.api.client.util.NanoClock;
import com.google.api.client.util.Sleeper;
import com.google.api.services.storage.Storage;
import com.google.api.services.storage.Storage.Objects.Get;
import com.google.api.services.storage.model.StorageObject;
import com.google.cloud.hadoop.gcsio.GoogleCloudStorageReadOptions.Fadvise;
import com.google.cloud.hadoop.gcsio.GoogleCloudStorageReadOptions.GenerationReadConsistency;
import com.google.cloud.hadoop.util.ApiErrorExtractor;
import com.google.cloud.hadoop.util.ClientRequestHelper;
import com.google.cloud.hadoop.util.ResilientOperation;
import com.google.cloud.hadoop.util.RetryDeterminer;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Supplier;
import com.google.common.base.Suppliers;
import com.google.common.flogger.GoogleLogger;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.channels.Channels;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.SeekableByteChannel;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/** Provides seekable read access to GCS. */
public class GoogleCloudStorageReadChannel implements SeekableByteChannel {

<span class="fc" id="L63">  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();</span>

  // Size of buffer to allocate for skipping bytes in-place when performing in-place seeks.
  @VisibleForTesting static final int SKIP_BUFFER_SIZE = 8192;

  private static final String GZIP_ENCODING = &quot;gzip&quot;;

  // GCS access instance.
  private final Storage gcs;

  // Name of the bucket containing the object being read.
  private final String bucketName;

  // Name of the object being read.
  private final String objectName;

  // GCS resource/object path, used for logging.
  private final Object resourceIdString;

  // GCS object content channel.
  @VisibleForTesting ReadableByteChannel contentChannel;

  // True if this channel is open, false otherwise.
<span class="fc" id="L86">  private boolean channelIsOpen = true;</span>

  // Current position in this channel, it could be different from contentChannelPosition if
  // position(long) method calls were made without calls to read(ByteBuffer) method.
  // TODO(b/120887495): This @VisibleForTesting annotation was being ignored by prod code.
  // Please check that removing it is correct, and remove this comment along with it.
  // @VisibleForTesting
<span class="fc" id="L93">  protected long currentPosition = 0;</span>

  // Current read position in the contentChannel.
  //
  // When a caller calls position(long) to set stream position, we record the target position
  // and defer the actual seek operation until the caller tries to read from the channel.
  // This allows us to avoid an unnecessary seek to position 0 that would take place on creation
  // of this instance in cases where caller intends to start reading at some other offset.
  // If contentChannelPosition is not the same as currentPosition, it indicates that a target
  // position has been set but the actual seek operation is still pending.
  // TODO(b/120887495): This @VisibleForTesting annotation was being ignored by prod code.
  // Please check that removing it is correct, and remove this comment along with it.
  // @VisibleForTesting
<span class="fc" id="L106">  protected long contentChannelPosition = -1;</span>

  // Size of the object being read.
<span class="fc" id="L109">  private long size = -1;</span>

  // Size of the contentChannel.
<span class="fc" id="L112">  private long contentChannelEnd = -1;</span>

  // Whether to use bounded range requests or streaming requests.
  @VisibleForTesting boolean randomAccess;

  // Maximum number of automatic retries when reading from the underlying channel without making
  // progress; each time at least one byte is successfully read, the counter of attempted retries
  // is reset.
  // TODO(user): Wire this setting out to GHFS; it should correspond to adding the wiring for
  // setting the equivalent value inside HttpRequest.java that determines the low-level retries
  // during &quot;execute()&quot; calls. The default in HttpRequest.java is also 10.
<span class="fc" id="L123">  private int maxRetries = 10;</span>

  // Helper delegate for turning IOExceptions from API calls into higher-level semantics.
  private final ApiErrorExtractor errorExtractor;

  // Request helper to use to set extra headers
  private final ClientRequestHelper&lt;StorageObject&gt; clientRequestHelper;

  // Fine-grained options.
  private final GoogleCloudStorageReadOptions readOptions;

  // Sleeper used for waiting between retries.
<span class="fc" id="L135">  private Sleeper sleeper = Sleeper.DEFAULT;</span>

  // The clock used by ExponentialBackOff to determine when the maximum total elapsed time has
  // passed doing a series of retries.
<span class="fc" id="L139">  private NanoClock clock = NanoClock.SYSTEM;</span>

  // read operation gets its own Exponential Backoff Strategy,
  // to avoid interference with other operations in nested retries.
<span class="fc" id="L143">  private Supplier&lt;BackOff&gt; readBackOff = Suppliers.memoize(this::createBackOff);</span>

  // Used as scratch space when reading bytes just to discard them when trying to perform small
  // in-place seeks.
<span class="fc" id="L147">  private byte[] skipBuffer = null;</span>

  // Whether object content is gzip-encoded.
<span class="fc" id="L150">  private boolean gzipEncoded = false;</span>

  // Prefetched footer content.
  // TODO(b/110832992):
  // 1. Test showing footer prefetch avoids another request to GCS.
  // 2. Test showing shorter footer prefetch does not cause any problems.
  // 3. Test that footer prefetch always disabled for gzipped files.
  private byte[] footerContent;

<span class="fc" id="L159">  private Long generation = null;</span>

<span class="fc" id="L161">  @VisibleForTesting protected boolean metadataInitialized = false;</span>

  /**
   * Constructs an instance of GoogleCloudStorageReadChannel.
   *
   * @param gcs storage object instance
   * @param bucketName name of the bucket containing the object to read
   * @param objectName name of the object to read
   * @param requestHelper a ClientRequestHelper used to set any extra headers
   * @throws IOException on IO error
   */
  public GoogleCloudStorageReadChannel(
      Storage gcs,
      String bucketName,
      String objectName,
      ApiErrorExtractor errorExtractor,
      ClientRequestHelper&lt;StorageObject&gt; requestHelper)
      throws IOException {
<span class="nc" id="L179">    this(</span>
        gcs,
        bucketName,
        objectName,
        errorExtractor,
        requestHelper,
        GoogleCloudStorageReadOptions.DEFAULT);
<span class="nc" id="L186">  }</span>

  /**
   * Constructs an instance of GoogleCloudStorageReadChannel.
   *
   * @param gcs storage object instance
   * @param bucketName name of the bucket containing the object to read
   * @param objectName name of the object to read
   * @param requestHelper a ClientRequestHelper used to set any extra headers
   * @param readOptions fine-grained options specifying things like retry settings, buffering, etc.
   *     Could not be null.
   * @throws IOException on IO error
   */
  public GoogleCloudStorageReadChannel(
      Storage gcs,
      String bucketName,
      String objectName,
      ApiErrorExtractor errorExtractor,
      ClientRequestHelper&lt;StorageObject&gt; requestHelper,
      @Nonnull GoogleCloudStorageReadOptions readOptions)
<span class="fc" id="L206">      throws IOException {</span>
<span class="fc" id="L207">    this.gcs = gcs;</span>
<span class="fc" id="L208">    this.clientRequestHelper = requestHelper;</span>
<span class="fc" id="L209">    this.bucketName = bucketName;</span>
<span class="fc" id="L210">    this.objectName = objectName;</span>
<span class="fc" id="L211">    this.errorExtractor = errorExtractor;</span>
<span class="fc" id="L212">    this.readOptions = readOptions;</span>
    // TODO: micro benchmark if this necessary
<span class="fc" id="L214">    this.resourceIdString = lazyToString(() -&gt; createReadableString(bucketName, objectName));</span>

    // Initialize metadata if available.
<span class="fc" id="L217">    GoogleCloudStorageItemInfo info = getInitialMetadata();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">    if (info != null) {</span>
<span class="fc" id="L219">      initMetadata(info);</span>
    }
<span class="fc" id="L221">  }</span>

  /**
   * Used for unit testing only. Do not use elsewhere.
   *
   * &lt;p&gt;Constructs an instance of GoogleCloudStorageReadChannel.
   *
   * @param readOptions fine-grained options specifying things like retry settings, buffering, etc.
   *     Could not be null.
   * @throws IOException on IO error
   */
  // TODO(b/120887495): This @VisibleForTesting annotation was being ignored by prod code.
  // Please check that removing it is correct, and remove this comment along with it.
  // @VisibleForTesting
  protected GoogleCloudStorageReadChannel(@Nonnull GoogleCloudStorageReadOptions readOptions)
      throws IOException {
<span class="fc" id="L237">    this(</span>
        /* gcs= */ null,
        /* bucketName= */ null,
        /* objectName= */ null,
        /* errorExtractor= */ null,
        /* requestHelper= */ null,
        readOptions);
<span class="fc" id="L244">  }</span>

  /** Sets the Sleeper used for sleeping between retries. */
  @VisibleForTesting
  void setSleeper(Sleeper sleeper) {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">    Preconditions.checkArgument(sleeper != null, &quot;sleeper must not be null!&quot;);</span>
<span class="fc" id="L250">    this.sleeper = sleeper;</span>
<span class="fc" id="L251">  }</span>

  /** Sets the clock to be used for determining when max total time has elapsed doing retries. */
  @VisibleForTesting
  void setNanoClock(NanoClock clock) {
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">    Preconditions.checkArgument(clock != null, &quot;clock must not be null!&quot;);</span>
<span class="fc" id="L257">    this.clock = clock;</span>
<span class="fc" id="L258">  }</span>

  /**
   * Sets the back-off for determining sleep duration between read retries.
   *
   * @param backOff {@link BackOff} to use for read retries, could not be null.
   */
  void setReadBackOff(BackOff backOff) {
<span class="fc" id="L266">    this.readBackOff = Suppliers.ofInstance(checkNotNull(backOff, &quot;backOff could not be null&quot;));</span>
<span class="fc" id="L267">  }</span>

  /** Gets the back-off used for determining sleep duration between read retries. */
  @VisibleForTesting
  BackOff getReadBackOff() {
<span class="nc" id="L272">    return readBackOff.get();</span>
  }

  /** Creates new generic BackOff used for retries. */
  @VisibleForTesting
  ExponentialBackOff createBackOff() {
<span class="fc" id="L278">    return new ExponentialBackOff.Builder()</span>
<span class="fc" id="L279">        .setInitialIntervalMillis(readOptions.getBackoffInitialIntervalMillis())</span>
<span class="fc" id="L280">        .setRandomizationFactor(readOptions.getBackoffRandomizationFactor())</span>
<span class="fc" id="L281">        .setMultiplier(readOptions.getBackoffMultiplier())</span>
<span class="fc" id="L282">        .setMaxIntervalMillis(readOptions.getBackoffMaxIntervalMillis())</span>
<span class="fc" id="L283">        .setMaxElapsedTimeMillis(readOptions.getBackoffMaxElapsedTimeMillis())</span>
<span class="fc" id="L284">        .setNanoClock(clock)</span>
<span class="fc" id="L285">        .build();</span>
  }

  /**
   * Returns {@link GoogleCloudStorageItemInfo} used to initialize metadata in constructor or {@code
   * null} if {@link GoogleCloudStorageReadOptions#getFastFailOnNotFound()} is set to {@code false}.
   */
  @Nullable
  protected GoogleCloudStorageItemInfo getInitialMetadata() throws IOException {
<span class="fc bfc" id="L294" title="All 2 branches covered.">    return readOptions.getFastFailOnNotFound() ? fetchInitialMetadata() : null;</span>
  }

  /** Returns {@link GoogleCloudStorageItemInfo} used to initialize metadata in constructor. */
  private GoogleCloudStorageItemInfo fetchInitialMetadata() throws IOException {
    StorageObject object;
    try {
<span class="fc" id="L301">      object =</span>
<span class="fc" id="L302">          ResilientOperation.retry(</span>
<span class="fc" id="L303">              ResilientOperation.getGoogleRequestCallable(createRequest()),</span>
<span class="fc" id="L304">              readBackOff.get(),</span>
              RetryDeterminer.SOCKET_ERRORS,
              IOException.class,
              sleeper);
<span class="nc" id="L308">    } catch (IOException e) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">      throw errorExtractor.itemNotFound(e)</span>
<span class="nc" id="L310">          ? GoogleCloudStorageExceptions.getFileNotFoundException(bucketName, objectName)</span>
          : new IOException(&quot;Error reading &quot; + resourceIdString, e);
<span class="nc" id="L312">    } catch (InterruptedException e) { // From the sleep</span>
<span class="nc" id="L313">      throw new IOException(&quot;Thread interrupt received.&quot;, e);</span>
<span class="fc" id="L314">    }</span>
<span class="fc" id="L315">    return createItemInfoForStorageObject(new StorageResourceId(bucketName, objectName), object);</span>
  }

  /**
   * Sets the number of times to automatically retry by re-opening the underlying contentChannel
   * whenever an exception occurs while reading from it. The count of attempted retries is reset
   * whenever at least one byte is successfully read, so this number of retries refers to retries
   * made without achieving any forward progress.
   */
  public void setMaxRetries(int maxRetries) {
<span class="fc" id="L325">    this.maxRetries = maxRetries;</span>
<span class="fc" id="L326">  }</span>

  /**
   * Reads from this channel and stores read data in the given buffer.
   *
   * &lt;p&gt;On unexpected failure, will attempt to close the channel and clean up state.
   *
   * @param buffer buffer to read data into
   * @return number of bytes read or -1 on end-of-stream
   * @throws IOException on IO error
   */
  @Override
  public int read(ByteBuffer buffer) throws IOException {
<span class="fc" id="L339">    throwIfNotOpen();</span>

    // Don't try to read if the buffer has no space.
<span class="fc bfc" id="L342" title="All 2 branches covered.">    if (buffer.remaining() == 0) {</span>
<span class="fc" id="L343">      return 0;</span>
    }

<span class="fc" id="L346">    logger.atFine().log(</span>
        &quot;Reading %s bytes at %s position from '%s'&quot;,
<span class="fc" id="L348">        buffer.remaining(), currentPosition, resourceIdString);</span>

    // Do not perform any further reads if we already read everything from this channel.
<span class="fc bfc" id="L351" title="All 2 branches covered.">    if (currentPosition == size) {</span>
<span class="fc" id="L352">      return -1;</span>
    }

<span class="fc" id="L355">    int totalBytesRead = 0;</span>
<span class="fc" id="L356">    int retriesAttempted = 0;</span>

    // We read from a streaming source. We may not get all the bytes we asked for
    // in the first read. Therefore, loop till we either read the required number of
    // bytes or we reach end-of-stream.
    do {
<span class="fc" id="L362">      int remainingBeforeRead = buffer.remaining();</span>
<span class="fc" id="L363">      performLazySeek(remainingBeforeRead);</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">      checkState(</span>
          contentChannelPosition == currentPosition,
          &quot;contentChannelPosition (%s) should be equal to currentPosition (%s) after lazy seek&quot;,
          contentChannelPosition, currentPosition);

      try {
<span class="fc" id="L370">        int numBytesRead = contentChannel.read(buffer);</span>
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">        checkIOPrecondition(numBytesRead != 0, &quot;Read 0 bytes without blocking&quot;);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (numBytesRead &lt; 0) {</span>
          // Because we don't know decompressed object size for gzip-encoded objects,
          // assume that this is an object end.
<span class="fc bfc" id="L375" title="All 2 branches covered.">          if (gzipEncoded) {</span>
<span class="fc" id="L376">            size = currentPosition;</span>
<span class="fc" id="L377">            contentChannelEnd = currentPosition;</span>
          }
          // Check that we didn't get a premature End of Stream signal by checking the number of
          // bytes read against the stream size. Unfortunately we don't have information about the
          // actual size of the data stream when stream compression is used, so we can only ignore
          // this case here.
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">          checkIOPrecondition(</span>
              currentPosition == contentChannelEnd || currentPosition == size,
<span class="fc" id="L385">              String.format(</span>
                  &quot;Received end of stream result before all the file data has been received; &quot;
                      + &quot;totalBytesRead: %d, currentPosition: %d,&quot;
                      + &quot; contentChannelEnd %d, size: %d, object: '%s'&quot;,
<span class="fc" id="L389">                  totalBytesRead, currentPosition, contentChannelEnd, size, resourceIdString));</span>

          // If we have reached an end of a contentChannel but not an end of an object
          // then close contentChannel and continue reading an object if necessary.
<span class="pc bpc" id="L393" title="1 of 4 branches missed.">          if (contentChannelEnd != size &amp;&amp; currentPosition == contentChannelEnd) {</span>
<span class="fc" id="L394">            closeContentChannel();</span>
          } else {
<span class="fc" id="L396">            break;</span>
          }
        }

<span class="fc bfc" id="L400" title="All 2 branches covered.">        if (numBytesRead &gt; 0) {</span>
<span class="fc" id="L401">          totalBytesRead += numBytesRead;</span>
<span class="fc" id="L402">          currentPosition += numBytesRead;</span>
<span class="fc" id="L403">          contentChannelPosition += numBytesRead;</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">          checkState(</span>
              contentChannelPosition == currentPosition,
              &quot;contentChannelPosition (%s) should be equal to currentPosition (%s)&quot;
                  + &quot; after successful read&quot;,
              contentChannelPosition, currentPosition);
        }

<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (retriesAttempted != 0) {</span>
<span class="fc" id="L412">          logger.atInfo().log(</span>
              &quot;Success after %s retries on reading '%s'&quot;, retriesAttempted, resourceIdString);
        }
        // The count of retriesAttempted is per low-level contentChannel.read call;
        // each time we make progress we reset the retry counter.
<span class="fc" id="L417">        retriesAttempted = 0;</span>
<span class="fc" id="L418">      } catch (IOException ioe) {</span>
<span class="fc" id="L419">        logger.atFine().log(</span>
            &quot;Closing contentChannel after %s exception for '%s'.&quot;,
<span class="fc" id="L421">            ioe.getMessage(), resourceIdString);</span>
<span class="fc" id="L422">        closeContentChannel();</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">        if (buffer.remaining() != remainingBeforeRead) {</span>
<span class="fc" id="L425">          int partialRead = remainingBeforeRead - buffer.remaining();</span>
<span class="fc" id="L426">          logger.atInfo().log(</span>
              &quot;Despite exception, had partial read of %s bytes from '%s'; resetting retry count.&quot;,
              partialRead, resourceIdString);
<span class="fc" id="L429">          retriesAttempted = 0;</span>
<span class="fc" id="L430">          totalBytesRead += partialRead;</span>
<span class="fc" id="L431">          currentPosition += partialRead;</span>
        }

        // TODO(user): Refactor any reusable logic for retries into a separate RetryHelper class.
<span class="fc bfc" id="L435" title="All 2 branches covered.">        if (retriesAttempted == maxRetries) {</span>
<span class="fc" id="L436">          logger.atSevere().log(</span>
              &quot;Throwing exception after reaching max read retries (%s) for '%s'.&quot;,
              maxRetries, resourceIdString);
<span class="fc" id="L439">          throw ioe;</span>
        }

<span class="fc bfc" id="L442" title="All 2 branches covered.">        if (retriesAttempted == 0) {</span>
          // If this is the first of a series of retries, we also want to reset the readBackOff
          // to have fresh initial values.
<span class="fc" id="L445">          readBackOff.get().reset();</span>
        }

<span class="fc" id="L448">        ++retriesAttempted;</span>
<span class="fc" id="L449">        logger.atWarning().withCause(ioe).log(</span>
            &quot;Failed read retry #%s/%s for '%s'. Sleeping...&quot;,
<span class="fc" id="L451">            retriesAttempted, maxRetries, resourceIdString);</span>
        try {
<span class="fc" id="L453">          boolean backOffSuccessful = BackOffUtils.next(sleeper, readBackOff.get());</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">          if (!backOffSuccessful) {</span>
<span class="fc" id="L455">            logger.atSevere().log(</span>
                &quot;BackOff returned false; maximum total elapsed time exhausted.&quot;
                    + &quot; Giving up after %s/%s retries for '%s'&quot;,
<span class="fc" id="L458">                retriesAttempted, maxRetries, resourceIdString);</span>
<span class="fc" id="L459">            throw ioe;</span>
          }
<span class="fc" id="L461">        } catch (InterruptedException ie) {</span>
<span class="fc" id="L462">          logger.atSevere().log(</span>
              &quot;Interrupted while sleeping before retry. Giving up after %s/%s retries for '%s'&quot;,
<span class="fc" id="L464">              retriesAttempted, maxRetries, resourceIdString);</span>
<span class="fc" id="L465">          ioe.addSuppressed(ie);</span>
<span class="fc" id="L466">          throw ioe;</span>
<span class="fc" id="L467">        }</span>

<span class="fc" id="L469">        logger.atInfo().log(</span>
            &quot;Done sleeping before retry #%s/%s for '%s'&quot;,
<span class="fc" id="L471">            retriesAttempted, maxRetries, resourceIdString);</span>
<span class="fc" id="L472">      } catch (RuntimeException r) {</span>
<span class="fc" id="L473">        closeContentChannel();</span>
<span class="fc" id="L474">        throw r;</span>
<span class="fc" id="L475">      }</span>
<span class="fc bfc" id="L476" title="All 4 branches covered.">    } while (buffer.remaining() &gt; 0 &amp;&amp; currentPosition &lt; size);</span>

    // If this method was called when the stream was already at EOF
    // (indicated by totalBytesRead == 0) then return EOF else,
    // return the number of bytes read.
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">    boolean isEndOfStream = (totalBytesRead == 0);</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">    if (isEndOfStream) {</span>
      // Check that we didn't get a premature End of Stream signal by checking the number of bytes
      // read against the stream size. Unfortunately we don't have information about the actual size
      // of the data stream when stream compression is used, so we can only ignore this case here.
<span class="nc bnc" id="L486" title="All 2 branches missed.">      checkIOPrecondition(</span>
          currentPosition == size,
<span class="nc" id="L488">          String.format(</span>
              &quot;Failed to read any data before all the file data has been received;&quot;
                  + &quot; currentPosition: %d, size: %d, object '%s'&quot;,
<span class="nc" id="L491">              currentPosition, size, resourceIdString));</span>
<span class="nc" id="L492">      return -1;</span>
    }
<span class="fc" id="L494">    return totalBytesRead;</span>
  }

  @Override
  public SeekableByteChannel truncate(long size) throws IOException {
<span class="nc" id="L499">    throw new UnsupportedOperationException(&quot;Cannot mutate read-only channel&quot;);</span>
  }

  @Override
  public int write(ByteBuffer src) throws IOException {
<span class="nc" id="L504">    throw new UnsupportedOperationException(&quot;Cannot mutate read-only channel&quot;);</span>
  }

  /**
   * Tells whether this channel is open.
   *
   * @return a value indicating whether this channel is open
   */
  @Override
  public boolean isOpen() {
<span class="fc" id="L514">    return channelIsOpen;</span>
  }

  /**
   * Closes the underlying {@link ReadableByteChannel}.
   *
   * &lt;p&gt;Catches and ignores all exceptions as there is not a lot the user can do to fix errors here
   * and a new connection will be needed. Especially SSLExceptions since the there's a high
   * probability that SSL connections would be broken in a way that causes {@link
   * java.nio.channels.Channel#close()} itself to throw an exception, even though underlying sockets
   * have already been cleaned up; close() on an SSLSocketImpl requires a shutdown handshake in
   * order to shutdown cleanly, and if the connection has been broken already, then this is not
   * possible, and the SSLSocketImpl was already responsible for performing local cleanup at the
   * time the exception was raised.
   */
  protected void closeContentChannel() {
<span class="fc bfc" id="L530" title="All 2 branches covered.">    if (contentChannel != null) {</span>
<span class="fc" id="L531">      logger.atFine().log(&quot;Closing internal contentChannel for '%s'&quot;, resourceIdString);</span>
      try {
<span class="fc" id="L533">        contentChannel.close();</span>
<span class="fc" id="L534">      } catch (Exception e) {</span>
<span class="fc" id="L535">        logger.atFine().withCause(e).log(</span>
            &quot;Got an exception on contentChannel.close() for '%s'; ignoring it.&quot;, resourceIdString);
      } finally {
<span class="fc" id="L538">        contentChannel = null;</span>
<span class="fc" id="L539">        resetContentChannel();</span>
      }
    }
<span class="fc" id="L542">  }</span>

  private void resetContentChannel() {
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">    checkState(contentChannel == null, &quot;contentChannel should be null for '%s'&quot;, resourceIdString);</span>
<span class="fc" id="L546">    contentChannelPosition = -1;</span>
<span class="fc" id="L547">    contentChannelEnd = -1;</span>
<span class="fc" id="L548">  }</span>

  /**
   * Closes this channel.
   *
   * @throws IOException on IO error
   */
  @Override
  public void close() throws IOException {
<span class="fc bfc" id="L557" title="All 2 branches covered.">    if (!channelIsOpen) {</span>
<span class="fc" id="L558">      logger.atFine().log(&quot;Ignoring close: channel for '%s' is not open.&quot;, resourceIdString);</span>
<span class="fc" id="L559">      return;</span>
    }
<span class="fc" id="L561">    logger.atFine().log(&quot;Closing channel for '%s'&quot;, resourceIdString);</span>
<span class="fc" id="L562">    channelIsOpen = false;</span>
<span class="fc" id="L563">    closeContentChannel();</span>
<span class="fc" id="L564">  }</span>

  /**
   * Returns this channel's current position.
   *
   * @return this channel's current position
   */
  @Override
  public long position() throws IOException {
<span class="fc" id="L573">    throwIfNotOpen();</span>
<span class="fc" id="L574">    return currentPosition;</span>
  }

  /**
   * Sets this channel's position.
   *
   * &lt;p&gt;This method will throw an exception if {@code newPosition} is greater than object size,
   * which contradicts {@link SeekableByteChannel#position(long) SeekableByteChannel} contract.
   * TODO(user): decide if this needs to be fixed.
   *
   * @param newPosition the new position, counting the number of bytes from the beginning.
   * @return this channel instance
   * @throws java.io.FileNotFoundException if the underlying object does not exist.
   * @throws IOException on IO error
   */
  @Override
  public SeekableByteChannel position(long newPosition) throws IOException {
<span class="fc" id="L591">    throwIfNotOpen();</span>

<span class="fc bfc" id="L593" title="All 2 branches covered.">    if (newPosition == currentPosition) {</span>
<span class="fc" id="L594">      return this;</span>
    }

<span class="fc" id="L597">    validatePosition(newPosition);</span>
<span class="fc" id="L598">    logger.atFine().log(</span>
<span class="fc" id="L599">        &quot;Seek from %s to %s position for '%s'&quot;, currentPosition, newPosition, resourceIdString);</span>
<span class="fc" id="L600">    currentPosition = newPosition;</span>
<span class="fc" id="L601">    return this;</span>
  }

  private boolean isRandomAccessPattern(long oldPosition) {
<span class="fc bfc" id="L605" title="All 2 branches covered.">    if (!shouldDetectRandomAccess()) {</span>
<span class="fc" id="L606">      return false;</span>
    }
<span class="fc bfc" id="L608" title="All 2 branches covered.">    if (currentPosition &lt; oldPosition) {</span>
<span class="fc" id="L609">      logger.atFine().log(</span>
          &quot;Detected backward read from %s to %s position, switching to random IO for '%s'&quot;,
<span class="fc" id="L611">          oldPosition, currentPosition, resourceIdString);</span>
<span class="fc" id="L612">      return true;</span>
    }
<span class="fc bfc" id="L614" title="All 4 branches covered.">    if (oldPosition &gt;= 0 &amp;&amp; oldPosition + readOptions.getInplaceSeekLimit() &lt; currentPosition) {</span>
<span class="fc" id="L615">      logger.atFine().log(</span>
          &quot;Detected forward read from %s to %s position over %s threshold,&quot;
              + &quot; switching to random IO for '%s'&quot;,
<span class="fc" id="L618">          oldPosition, currentPosition, readOptions.getInplaceSeekLimit(), resourceIdString);</span>
<span class="fc" id="L619">      return true;</span>
    }
<span class="fc" id="L621">    return false;</span>
  }

  private boolean shouldDetectRandomAccess() {
<span class="fc bfc" id="L625" title="All 6 branches covered.">    return !gzipEncoded &amp;&amp; !randomAccess &amp;&amp; readOptions.getFadvise() == Fadvise.AUTO;</span>
  }

  private void setRandomAccess() {
<span class="fc" id="L629">    randomAccess = true;</span>
<span class="fc" id="L630">    checkEncodingAndAccess();</span>
<span class="fc" id="L631">  }</span>

  private void skipInPlace(long seekDistance) {
<span class="pc bpc" id="L634" title="1 of 2 branches missed.">    if (skipBuffer == null) {</span>
<span class="fc" id="L635">      skipBuffer = new byte[SKIP_BUFFER_SIZE];</span>
    }
<span class="fc bfc" id="L637" title="All 4 branches covered.">    while (seekDistance &gt; 0 &amp;&amp; contentChannel != null) {</span>
      try {
<span class="fc" id="L639">        int bufferSize = Math.toIntExact(Math.min(skipBuffer.length, seekDistance));</span>
<span class="fc" id="L640">        int bytesRead = contentChannel.read(ByteBuffer.wrap(skipBuffer, 0, bufferSize));</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (bytesRead &lt; 0) {</span>
          // Shouldn't happen since we called validatePosition prior to this loop.
<span class="nc" id="L643">          logger.atInfo().log(</span>
              &quot;Somehow read %s bytes trying to skip %s bytes to seek to position %s, size: %s&quot;,
<span class="nc" id="L645">              bytesRead, seekDistance, currentPosition, size);</span>
<span class="nc" id="L646">          closeContentChannel();</span>
        } else {
<span class="fc" id="L648">          seekDistance -= bytesRead;</span>
<span class="fc" id="L649">          contentChannelPosition += bytesRead;</span>
        }
<span class="fc" id="L651">      } catch (IOException e) {</span>
<span class="fc" id="L652">        logger.atInfo().withCause(e).log(</span>
            &quot;Got an IO exception on contentChannel.read(), a lazy-seek will be pending for '%s'&quot;,
            resourceIdString);
<span class="fc" id="L655">        closeContentChannel();</span>
<span class="fc" id="L656">      }</span>
    }
<span class="pc bpc" id="L658" title="1 of 4 branches missed.">    checkState(</span>
        contentChannel == null || contentChannelPosition == currentPosition,
        &quot;contentChannelPosition (%s) should be equal to currentPosition (%s)&quot;
            + &quot; after successful in-place skip&quot;,
        contentChannelPosition, currentPosition);
<span class="fc" id="L663">  }</span>

  /**
   * Returns size of the object to which this channel is connected.
   *
   * &lt;p&gt;Note: this method will return -1 until metadata will be lazily initialized during first
   * {@link #read} method call.
   *
   * @return size of the object to which this channel is connected after metadata was initialized
   *     (during first read) or {@code -1} otherwise.
   * @throws IOException on IO error
   */
  @Override
  public long size() throws IOException {
<span class="fc" id="L677">    throwIfNotOpen();</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">    if (!metadataInitialized) {</span>
<span class="fc" id="L679">      initMetadata(fetchInitialMetadata());</span>
    }
<span class="fc" id="L681">    return size;</span>
  }

  /** Sets size of this channel to the given value. */
  // TODO(b/120887495): This @VisibleForTesting annotation was being ignored by prod code.
  // Please check that removing it is correct, and remove this comment along with it.
  // @VisibleForTesting
  protected void setSize(long size) {
<span class="fc" id="L689">    this.size = size;</span>
<span class="fc" id="L690">  }</span>

  private void checkEncodingAndAccess() {
<span class="pc bpc" id="L693" title="1 of 4 branches missed.">    checkState(</span>
        !(gzipEncoded &amp;&amp; randomAccess),
        &quot;gzipEncoded and randomAccess should not be true at the same time for '%s'&quot;,
        resourceIdString);
<span class="fc" id="L697">  }</span>

  /** Validates that the given position is valid for this channel. */
  protected void validatePosition(long position) throws IOException {
<span class="fc bfc" id="L701" title="All 2 branches covered.">    if (position &lt; 0) {</span>
<span class="fc" id="L702">      throw new EOFException(</span>
<span class="fc" id="L703">          String.format(</span>
              &quot;Invalid seek offset: position value (%d) must be &gt;= 0 for '%s'&quot;,
<span class="fc" id="L705">              position, resourceIdString));</span>
    }

<span class="fc bfc" id="L708" title="All 4 branches covered.">    if (size &gt;= 0 &amp;&amp; position &gt;= size) {</span>
<span class="fc" id="L709">      throw new EOFException(</span>
<span class="fc" id="L710">          String.format(</span>
              &quot;Invalid seek offset: position value (%d) must be between 0 and %d for '%s'&quot;,
<span class="fc" id="L712">              position, size, resourceIdString));</span>
    }
<span class="fc" id="L714">  }</span>

  /**
   * Seeks to the {@link #currentPosition} in the underlying stream or opens new stream at {@link
   * #currentPosition}.
   *
   * &lt;p&gt;Note: Seek could be an expensive operation if a new stream is opened.
   *
   * @param bytesToRead number of bytes to read, used only if new stream is opened.
   * @throws java.io.FileNotFoundException if the underlying object does not exist.
   * @throws IOException on IO error
   */
  @VisibleForTesting
  void performLazySeek(long bytesToRead) throws IOException {
<span class="fc" id="L728">    throwIfNotOpen();</span>

    // Return quickly if there is no pending seek operation, i.e. position didn't change.
<span class="pc bpc" id="L731" title="1 of 4 branches missed.">    if (currentPosition == contentChannelPosition &amp;&amp; contentChannel != null) {</span>
<span class="fc" id="L732">      return;</span>
    }

<span class="fc" id="L735">    logger.atFine().log(</span>
        &quot;Performing lazySeek from %s to %s position with %s bytesToRead for '%s'&quot;,
<span class="fc" id="L737">        contentChannelPosition, currentPosition, bytesToRead, resourceIdString);</span>

    // used to auto-detect random access
<span class="fc" id="L740">    long oldPosition = contentChannelPosition;</span>

<span class="fc" id="L742">    long seekDistance = currentPosition - contentChannelPosition;</span>
<span class="pc bpc" id="L743" title="1 of 6 branches missed.">    if (contentChannel != null</span>
        &amp;&amp; seekDistance &gt; 0
        // Always skip in place gzip-encoded files, because they do not support range reads.
<span class="fc bfc" id="L746" title="All 4 branches covered.">        &amp;&amp; (gzipEncoded || seekDistance &lt;= readOptions.getInplaceSeekLimit())</span>
        &amp;&amp; currentPosition &lt; contentChannelEnd) {
<span class="fc" id="L748">      logger.atFine().log(</span>
          &quot;Seeking forward %s bytes (inplaceSeekLimit: %s) in-place to position %s for '%s'&quot;,
<span class="fc" id="L750">          seekDistance, readOptions.getInplaceSeekLimit(), currentPosition, resourceIdString);</span>
<span class="fc" id="L751">      skipInPlace(seekDistance);</span>
    } else {
<span class="fc" id="L753">      closeContentChannel();</span>
    }

<span class="fc bfc" id="L756" title="All 2 branches covered.">    if (contentChannel == null) {</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">      if (isRandomAccessPattern(oldPosition)) {</span>
<span class="fc" id="L758">        setRandomAccess();</span>
      }
<span class="fc" id="L760">      openContentChannel(bytesToRead);</span>
    }
<span class="fc" id="L762">  }</span>

  private void openContentChannel(long bytesToRead) throws IOException {
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">    checkState(contentChannel == null, &quot;contentChannel should be null, before opening new&quot;);</span>
<span class="fc bfc" id="L766" title="All 4 branches covered.">    InputStream objectContentStream =</span>
        footerContent != null &amp;&amp; currentPosition &gt;= size - footerContent.length
<span class="fc" id="L768">            ? openFooterStream()</span>
<span class="fc" id="L769">            : openStream(bytesToRead);</span>
<span class="fc" id="L770">    contentChannel = Channels.newChannel(objectContentStream);</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">    checkState(</span>
        contentChannelPosition == currentPosition,
        &quot;contentChannelPosition (%s) should be equal to currentPosition (%s) for '%s'&quot;,
<span class="fc" id="L774">        contentChannelPosition, currentPosition, resourceIdString);</span>
<span class="fc" id="L775">  }</span>

  /* Initializes metadata (size, encoding, etc) from {@link GoogleCloudStorageItemInfo} */
  private void initMetadata(GoogleCloudStorageItemInfo info) throws IOException {
<span class="fc" id="L779">    String generationString = String.valueOf(info.getContentGeneration());</span>
<span class="fc" id="L780">    initMetadata(info.getContentEncoding(), info.getSize(), generationString);</span>
<span class="fc" id="L781">  }</span>

  /** Initializes metadata (size, encoding, etc) from HTTP {@code headers}. */
  @VisibleForTesting
  protected void initMetadata(HttpHeaders headers) throws IOException {
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">    checkState(</span>
        !metadataInitialized,
        &quot;can not initialize metadata, it already initialized for '%s'&quot;, resourceIdString);

    long sizeFromMetadata;
<span class="fc" id="L791">    String range = headers.getContentRange();</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">    if (range != null) {</span>
<span class="fc" id="L793">      sizeFromMetadata = Long.parseLong(range.substring(range.lastIndexOf('/') + 1));</span>
    } else {
<span class="fc" id="L795">      sizeFromMetadata = headers.getContentLength();</span>
    }

<span class="fc" id="L798">    String generation = headers.getFirstHeaderStringValue(&quot;x-goog-generation&quot;);</span>

<span class="fc" id="L800">    initMetadata(headers.getContentEncoding(), sizeFromMetadata, generation);</span>
<span class="fc" id="L801">  }</span>

  /** Initializes metadata (size, encoding, etc) from passed parameters. */
  @VisibleForTesting
  protected void initMetadata(
      @Nullable String encoding, long sizeFromMetadata, @Nullable String generation)
      throws IOException {
<span class="pc bpc" id="L808" title="1 of 2 branches missed.">    checkState(</span>
        !metadataInitialized,
        &quot;can not initialize metadata, it already initialized for '%s'&quot;, resourceIdString);
<span class="fc" id="L811">    gzipEncoded = nullToEmpty(encoding).contains(GZIP_ENCODING);</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">    if (gzipEncoded) {</span>
<span class="fc" id="L813">      size = Long.MAX_VALUE;</span>
    } else {
<span class="fc" id="L815">      size = sizeFromMetadata;</span>
    }
<span class="fc bfc" id="L817" title="All 4 branches covered.">    randomAccess = !gzipEncoded &amp;&amp; readOptions.getFadvise() == Fadvise.RANDOM;</span>
<span class="fc" id="L818">    checkEncodingAndAccess();</span>

<span class="fc" id="L820">    initGeneration(generation);</span>

<span class="fc" id="L822">    metadataInitialized = true;</span>

<span class="fc" id="L824">    logger.atFine().log(</span>
        &quot;Initialized metadata (gzipEncoded=%s, size=%s, randomAccess=%s, generation=%s) for '%s'&quot;,
<span class="fc" id="L826">        gzipEncoded, size, randomAccess, generation, resourceIdString);</span>
<span class="fc" id="L827">  }</span>

  private void initGeneration(@Nullable String generationString) throws IOException {
<span class="fc bfc" id="L830" title="All 2 branches covered.">    if (readOptions.getGenerationReadConsistency().equals(GenerationReadConsistency.LATEST)) {</span>
<span class="fc" id="L831">      generation = null;</span>
    } else {
<span class="fc bfc" id="L833" title="All 2 branches covered.">      if (generationString == null) {</span>
<span class="fc" id="L834">        throw new IOException(</span>
<span class="fc" id="L835">            String.format(</span>
                &quot;Generation Read Consistency is '%s', but failed to retrieve generation for '%s'.&quot;,
<span class="fc" id="L837">                readOptions.getGenerationReadConsistency(), resourceIdString));</span>
      }
<span class="fc" id="L839">      generation = Long.parseLong(generationString);</span>
    }
<span class="fc" id="L841">  }</span>

  private void cacheFooter(HttpResponse response) throws IOException {
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">    checkState(size &gt; 0, &quot;size should be greater than 0 for '%s'&quot;, resourceIdString);</span>
<span class="fc" id="L845">    int footerSize = Math.toIntExact(response.getHeaders().getContentLength());</span>
<span class="fc" id="L846">    footerContent = new byte[footerSize];</span>
<span class="fc" id="L847">    try (InputStream footerStream = response.getContent()) {</span>
<span class="fc" id="L848">      int totalBytesRead = 0;</span>
<span class="fc" id="L849">      int bytesRead = 0;</span>
      do {
<span class="fc" id="L851">        totalBytesRead += bytesRead;</span>
<span class="fc" id="L852">        bytesRead = footerStream.read(footerContent, totalBytesRead, footerSize - totalBytesRead);</span>
<span class="pc bpc" id="L853" title="1 of 4 branches missed.">      } while (bytesRead &gt;= 0 &amp;&amp; totalBytesRead &lt;= footerSize);</span>
<span class="fc" id="L854">      checkState(</span>
<span class="pc bpc" id="L855" title="1 of 2 branches missed.">          footerStream.read() &lt; 0,</span>
          &quot;footerStream should be empty after reading %s bytes from %s bytes for '%s'&quot;,
<span class="fc" id="L857">          totalBytesRead, footerSize, resourceIdString);</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">      checkState(</span>
          totalBytesRead == footerSize,
          &quot;totalBytesRead (%s) should equal footerSize (%s) for '%s'&quot;,
<span class="fc" id="L861">          totalBytesRead, footerSize, resourceIdString);</span>
<span class="nc" id="L862">    } catch (IOException e) {</span>
<span class="nc" id="L863">      footerContent = null;</span>
<span class="nc" id="L864">      throw e;</span>
<span class="fc" id="L865">    }</span>
<span class="fc" id="L866">    logger.atFine().log(</span>
        &quot;Prefetched %s bytes footer for '%s'&quot;, footerContent.length, resourceIdString);
<span class="fc" id="L868">  }</span>

  /**
   * Opens the underlying stream from {@link #footerContent}, sets its position to the {@link
   * #currentPosition}.
   */
  private InputStream openFooterStream() {
<span class="fc" id="L875">    contentChannelPosition = currentPosition;</span>
<span class="fc" id="L876">    int offset = Math.toIntExact(currentPosition - (size - footerContent.length));</span>
<span class="fc" id="L877">    int length = footerContent.length - offset;</span>
<span class="fc" id="L878">    logger.atFine().log(</span>
        &quot;Opened stream (prefetched footer) from %s position for '%s'&quot;,
        currentPosition, resourceIdString);
<span class="fc" id="L881">    return new ByteArrayInputStream(footerContent, offset, length);</span>
  }

  /**
   * Opens the underlying stream, sets its position to the {@link #currentPosition}.
   *
   * &lt;p&gt;If the file encoding in GCS is gzip (and therefore the HTTP client will decompress it), the
   * entire file is always requested and we seek to the position requested. If the file encoding is
   * not gzip, only the remaining bytes to be read are requested from GCS.
   *
   * @param bytesToRead number of bytes to read from new stream. Ignored if {@link
   *     GoogleCloudStorageReadOptions#getFadvise()} is equal to {@link Fadvise#SEQUENTIAL}.
   * @throws IOException on IO error
   */
  protected InputStream openStream(long bytesToRead) throws IOException {
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">    checkArgument(bytesToRead &gt; 0, &quot;bytesToRead should be greater than 0, but was %s&quot;, bytesToRead);</span>

<span class="pc bpc" id="L898" title="2 of 4 branches missed.">    checkState(</span>
        contentChannel == null &amp;&amp; contentChannelEnd &lt; 0,
        &quot;contentChannel and contentChannelEnd should be not initialized yet for '%s'&quot;,
        resourceIdString);

<span class="pc bpc" id="L903" title="1 of 2 branches missed.">    if (size == 0) {</span>
<span class="nc" id="L904">      return new ByteArrayInputStream(new byte[0]);</span>
    }

    String rangeHeader;
<span class="fc bfc" id="L908" title="All 2 branches covered.">    if (!metadataInitialized) {</span>
<span class="fc" id="L909">      contentChannelPosition = getContentChannelPositionForFirstRead(bytesToRead);</span>
<span class="fc" id="L910">      rangeHeader = &quot;bytes=&quot; + contentChannelPosition + &quot;-&quot;;</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">      if (readOptions.getFadvise() == Fadvise.RANDOM) {</span>
<span class="fc" id="L912">        long maxBytesToRead = Math.max(readOptions.getMinRangeRequestSize(), bytesToRead);</span>
<span class="fc" id="L913">        rangeHeader += (contentChannelPosition + maxBytesToRead - 1);</span>
<span class="fc" id="L914">      }</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">    } else if (gzipEncoded) {</span>
      // Do not set range for gzip-encoded files - it's not supported.
<span class="fc" id="L917">      rangeHeader = null;</span>
      // Always read gzip-encoded files till the end - they do not support range reads.
<span class="fc" id="L919">      contentChannelPosition = 0;</span>
<span class="fc" id="L920">      contentChannelEnd = size;</span>
    } else {
<span class="fc bfc" id="L922" title="All 4 branches covered.">      if (readOptions.getFadvise() != Fadvise.SEQUENTIAL &amp;&amp; isFooterRead()) {</span>
        // Pre-fetch footer if reading end of file.
<span class="fc" id="L924">        contentChannelPosition = Math.max(0, size - readOptions.getMinRangeRequestSize());</span>
      } else {
<span class="fc" id="L926">        contentChannelPosition = currentPosition;</span>
      }

      // Set rangeSize to the size of the file reminder from currentPosition.
<span class="fc" id="L930">      long rangeSize = size - contentChannelPosition;</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">      if (randomAccess) {</span>
<span class="fc" id="L932">        long randomRangeSize = Math.max(bytesToRead, readOptions.getMinRangeRequestSize());</span>
        // Limit rangeSize to the randomRangeSize.
<span class="fc" id="L934">        rangeSize = Math.min(randomRangeSize, rangeSize);</span>
      }

<span class="fc" id="L937">      contentChannelEnd = contentChannelPosition + rangeSize;</span>
      // Do not read footer again, if it was already pre-fetched.
<span class="fc bfc" id="L939" title="All 2 branches covered.">      if (footerContent != null) {</span>
<span class="fc" id="L940">        contentChannelEnd = Math.min(contentChannelEnd, size - footerContent.length);</span>
      }

<span class="pc bpc" id="L943" title="1 of 2 branches missed.">      checkState(</span>
          currentPosition &lt; contentChannelEnd,
          &quot;currentPosition (%s) should be less than contentChannelEnd (%s) for '%s'&quot;,
<span class="fc" id="L946">          currentPosition, contentChannelEnd, resourceIdString);</span>
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">      checkState(</span>
          contentChannelPosition &lt;= currentPosition,
          &quot;contentChannelPosition (%s) should be less or equal to currentPosition (%s) for '%s'&quot;,
<span class="fc" id="L950">          contentChannelPosition, currentPosition, resourceIdString);</span>

<span class="fc" id="L952">      rangeHeader = &quot;bytes=&quot; + contentChannelPosition + &quot;-&quot;;</span>
<span class="pc bpc" id="L953" title="1 of 4 branches missed.">      if (randomAccess || contentChannelEnd != size) {</span>
<span class="fc" id="L954">        rangeHeader += (contentChannelEnd - 1);</span>
      }
    }
<span class="pc bpc" id="L957" title="1 of 4 branches missed.">    checkState(</span>
        !metadataInitialized || contentChannelEnd &gt; 0,
        &quot;contentChannelEnd should be initialized already for '%s'&quot;, resourceIdString);

<span class="fc" id="L961">    Get getObject = createDataRequest(rangeHeader);</span>
    HttpResponse response;
    try {
<span class="fc" id="L964">      response = getObject.executeMedia();</span>
      // TODO(b/110832992): validate response range header against expected/request range
<span class="fc" id="L966">    } catch (IOException e) {</span>
<span class="pc bpc" id="L967" title="5 of 6 branches missed.">      if (!metadataInitialized &amp;&amp; errorExtractor.rangeNotSatisfiable(e) &amp;&amp; currentPosition == 0) {</span>
        // We don't know the size yet (metadataInitialized == false) and we're seeking to byte 0,
        // but got 'range not satisfiable'; the object must be empty.
<span class="nc" id="L970">        logger.atInfo().log(</span>
            &quot;Got 'range not satisfiable' for reading '%s' at position 0; assuming empty.&quot;,
            resourceIdString);
<span class="nc" id="L973">        size = 0;</span>
<span class="nc" id="L974">        return new ByteArrayInputStream(new byte[0]);</span>
      }
<span class="fc" id="L976">      response = handleExecuteMediaException(e, getObject, shouldRetryWithLiveVersion());</span>
<span class="fc" id="L977">    }</span>

<span class="fc bfc" id="L979" title="All 2 branches covered.">    if (!metadataInitialized) {</span>
<span class="fc" id="L980">      initMetadata(response.getHeaders());</span>
<span class="fc" id="L981">      checkState(</span>
          metadataInitialized, &quot;metadata should be initialized already for '%s'&quot;, resourceIdString);
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">      if (size == 0) {</span>
<span class="nc" id="L984">        resetContentChannel();</span>
<span class="nc" id="L985">        return new ByteArrayInputStream(new byte[0]);</span>
      }
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">      if (gzipEncoded) {</span>
        // Initialize `contentChannelEnd` to `size` (initialized to Long.MAX_VALUE in `initMetadata`
        // method for gzipped objetcs) because value of HTTP Content-Length header is usually
        // smaller than decompressed object size.
<span class="nc bnc" id="L991" title="All 2 branches missed.">        if (currentPosition == 0) {</span>
<span class="nc" id="L992">          contentChannelEnd = size;</span>
        } else {
<span class="nc" id="L994">          resetContentChannel();</span>
<span class="nc" id="L995">          return openStream(bytesToRead);</span>
        }
      }
    }

<span class="fc bfc" id="L1000" title="All 2 branches covered.">    if (contentChannelEnd &lt; 0) {</span>
<span class="fc" id="L1001">      String contentRange = response.getHeaders().getContentRange();</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">      if (contentRange != null) {</span>
<span class="fc" id="L1003">        String contentEnd =</span>
<span class="fc" id="L1004">            contentRange.substring(</span>
<span class="fc" id="L1005">                contentRange.lastIndexOf('-') + 1, contentRange.lastIndexOf('/'));</span>
<span class="fc" id="L1006">        contentChannelEnd = Long.parseLong(contentEnd) + 1;</span>
<span class="fc" id="L1007">      } else {</span>
<span class="fc" id="L1008">        contentChannelEnd = response.getHeaders().getContentLength();</span>
      }
    }

<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">    checkState(</span>
        contentChannelEnd &gt; 0,
        &quot;contentChannelEnd should be initialized already for '%s'&quot;, resourceIdString);

<span class="fc bfc" id="L1016" title="All 2 branches covered.">    if (!gzipEncoded</span>
<span class="fc bfc" id="L1017" title="All 4 branches covered.">        &amp;&amp; readOptions.getFadvise() != Fadvise.SEQUENTIAL</span>
        &amp;&amp; contentChannelEnd == size
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        &amp;&amp; contentChannelEnd - contentChannelPosition &lt;= readOptions.getMinRangeRequestSize()) {</span>
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">      for (int retriesCount = 0; retriesCount &lt; maxRetries; retriesCount++) {</span>
        try {
<span class="fc" id="L1022">          cacheFooter(response);</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">          if (retriesCount != 0) {</span>
<span class="nc" id="L1024">            logger.atInfo().log(</span>
                &quot;Successfully cached footer after %s retries for '%s'&quot;,
                retriesCount, resourceIdString);
          }
<span class="fc" id="L1028">          break;</span>
<span class="nc" id="L1029">        } catch (IOException e) {</span>
<span class="nc" id="L1030">          logger.atInfo().withCause(e).log(</span>
              &quot;Failed to prefetch footer (retry #%s/%s) for '%s'&quot;,
<span class="nc" id="L1032">              retriesCount + 1, maxRetries, resourceIdString);</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">          if (retriesCount == 0) {</span>
<span class="nc" id="L1034">            readBackOff.get().reset();</span>
          }
<span class="nc bnc" id="L1036" title="All 2 branches missed.">          if (retriesCount == maxRetries) {</span>
<span class="nc" id="L1037">            resetContentChannel();</span>
<span class="nc" id="L1038">            throw e;</span>
          }
          try {
<span class="nc" id="L1041">            response = getObject.executeMedia();</span>
            // TODO(b/110832992): validate response range header against expected/request range.
<span class="nc" id="L1043">          } catch (IOException e1) {</span>
<span class="nc" id="L1044">            response = handleExecuteMediaException(e1, getObject, shouldRetryWithLiveVersion());</span>
<span class="nc" id="L1045">          }</span>
        }
      }
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">      checkState(</span>
          footerContent != null,
          &quot;footerContent should not be null after successful footer prefetch for '%s'&quot;,
          resourceIdString);
<span class="fc" id="L1052">      resetContentChannel();</span>
<span class="fc" id="L1053">      return openFooterStream();</span>
    }

    try {
<span class="fc" id="L1057">      InputStream contentStream = response.getContent();</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">      if (readOptions.getBufferSize() &gt; 0) {</span>
<span class="nc" id="L1059">        int bufferSize = readOptions.getBufferSize();</span>
        // limit buffer size to the channel end
<span class="nc" id="L1061">        bufferSize =</span>
<span class="nc" id="L1062">            Math.toIntExact(Math.min(bufferSize, contentChannelEnd - contentChannelPosition));</span>
<span class="nc" id="L1063">        logger.atFine().log(</span>
            &quot;Opened stream from %d position with %s range, %d bytesToRead&quot;
                + &quot; and %d bytes buffer for '%s'&quot;,
<span class="nc" id="L1066">            currentPosition, rangeHeader, bytesToRead, bufferSize, resourceIdString);</span>
<span class="nc" id="L1067">        contentStream = new BufferedInputStream(contentStream, bufferSize);</span>
<span class="nc" id="L1068">      } else {</span>
<span class="fc" id="L1069">        logger.atFine().log(</span>
            &quot;Opened stream from %d position with %s range and %d bytesToRead for '%s'&quot;,
<span class="fc" id="L1071">            currentPosition, rangeHeader, bytesToRead, resourceIdString);</span>
      }

<span class="fc bfc" id="L1074" title="All 2 branches covered.">      if (contentChannelPosition &lt; currentPosition) {</span>
<span class="fc" id="L1075">        long bytesToSkip = currentPosition - contentChannelPosition;</span>
<span class="fc" id="L1076">        logger.atFine().log(</span>
            &quot;Skipping %d bytes from %d position to %d position for '%s'&quot;,
<span class="fc" id="L1078">            bytesToSkip, contentChannelPosition, currentPosition, resourceIdString);</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        while (bytesToSkip &gt; 0) {</span>
<span class="fc" id="L1080">          long skippedBytes = contentStream.skip(bytesToSkip);</span>
<span class="fc" id="L1081">          logger.atFine().log(</span>
              &quot;Skipped %d bytes from %d position for '%s'&quot;,
<span class="fc" id="L1083">              skippedBytes, contentChannelPosition, resourceIdString);</span>
<span class="fc" id="L1084">          bytesToSkip -= skippedBytes;</span>
<span class="fc" id="L1085">          contentChannelPosition += skippedBytes;</span>
<span class="fc" id="L1086">        }</span>
      }

<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">      checkState(</span>
          contentChannelPosition == currentPosition,
          &quot;contentChannelPosition (%s) should be equal to currentPosition (%s) for '%s'&quot;,
<span class="fc" id="L1092">          contentChannelPosition, currentPosition, resourceIdString);</span>

<span class="fc" id="L1094">      return contentStream;</span>
<span class="nc" id="L1095">    } catch (IOException e) {</span>
      try {
<span class="nc" id="L1097">        response.disconnect();</span>
<span class="nc" id="L1098">      } catch (IOException closeException) {</span>
<span class="nc" id="L1099">        e.addSuppressed(closeException);</span>
<span class="nc" id="L1100">      }</span>
<span class="nc" id="L1101">      throw e;</span>
    }
  }

  private boolean isFooterRead() {
<span class="fc bfc" id="L1106" title="All 2 branches covered.">    return size - currentPosition &lt;= readOptions.getMinRangeRequestSize();</span>
  }

  private long getContentChannelPositionForFirstRead(long bytesToRead) {
<span class="fc bfc" id="L1110" title="All 2 branches covered.">    if (readOptions.getFadvise() == Fadvise.SEQUENTIAL</span>
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">        || bytesToRead &gt;= readOptions.getMinRangeRequestSize()) {</span>
<span class="fc" id="L1112">      return currentPosition;</span>
    }
    // Prefetch footer (bytes before 'currentPosition' in case of last byte read) lazily.
    // Max prefetch size is (minRangeRequestSize / 2) bytes.
<span class="nc bnc" id="L1116" title="All 2 branches missed.">    if (bytesToRead &lt;= readOptions.getMinRangeRequestSize() / 2) {</span>
<span class="nc" id="L1117">      return Math.max(0, currentPosition - readOptions.getMinRangeRequestSize() / 2);</span>
    }
<span class="nc" id="L1119">    return Math.max(0, currentPosition - (readOptions.getMinRangeRequestSize() - bytesToRead));</span>
  }

  private boolean shouldRetryWithLiveVersion() {
<span class="fc bfc" id="L1123" title="All 2 branches covered.">    return generation != null</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">        &amp;&amp; readOptions.getGenerationReadConsistency().equals(GenerationReadConsistency.BEST_EFFORT);</span>
  }

  /**
   * When an IOException is thrown, depending on if the exception is caused by non-existent object
   * generation, and depending on the generation read consistency setting, either retry the read (of
   * the latest generation), or handle the exception directly.
   *
   * @param e IOException thrown while reading from GCS.
   * @param getObject the Get request to GCS.
   * @param retryWithLiveVersion flag indicating whether we should strip the generation (thus read
   *     from the latest generation) and retry.
   * @return the HttpResponse of reading from GCS from possible retry.
   * @throws IOException either error on retry, or thrown because the original read encounters
   *     error.
   */
  private HttpResponse handleExecuteMediaException(
      IOException e, Get getObject, boolean retryWithLiveVersion) throws IOException {
<span class="fc bfc" id="L1142" title="All 2 branches covered.">    if (errorExtractor.itemNotFound(e)) {</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">      if (retryWithLiveVersion) {</span>
<span class="fc" id="L1144">        generation = null;</span>
<span class="fc" id="L1145">        footerContent = null;</span>
<span class="fc" id="L1146">        getObject.setGeneration(null);</span>
        try {
<span class="fc" id="L1148">          return getObject.executeMedia();</span>
<span class="nc" id="L1149">        } catch (IOException e1) {</span>
<span class="nc" id="L1150">          return handleExecuteMediaException(e1, getObject, /* retryWithLiveVersion= */ false);</span>
        }
      }
<span class="fc" id="L1153">      throw GoogleCloudStorageExceptions.getFileNotFoundException(bucketName, objectName);</span>
    }
<span class="fc" id="L1155">    String msg =</span>
<span class="fc" id="L1156">        String.format(&quot;Error reading '%s' at position %d&quot;, resourceIdString, currentPosition);</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">    if (errorExtractor.rangeNotSatisfiable(e)) {</span>
<span class="fc" id="L1158">      throw (EOFException) new EOFException(msg).initCause(e);</span>
    }
<span class="fc" id="L1160">    throw new IOException(msg, e);</span>
  }

  private Get createDataRequest(String rangeHeader) throws IOException {
<span class="fc" id="L1164">    Get getObject = createRequest();</span>
<span class="fc" id="L1165">    getObject.setGeneration(generation);</span>

    // Set the headers on the existing request headers that may have
    // been initialized with things like user-agent already.
<span class="fc" id="L1169">    HttpHeaders requestHeaders = clientRequestHelper.getRequestHeaders(getObject);</span>
    // Disable GCS decompressive transcoding.
<span class="fc" id="L1171">    requestHeaders.setAcceptEncoding(&quot;gzip&quot;);</span>
<span class="fc" id="L1172">    requestHeaders.setRange(rangeHeader);</span>

<span class="fc" id="L1174">    return getObject;</span>
  }

  protected Get createRequest() throws IOException {
<span class="fc" id="L1178">    return gcs.objects().get(bucketName, objectName);</span>
  }

  /** Throws if this channel is not currently open. */
  private void throwIfNotOpen() throws IOException {
<span class="fc bfc" id="L1183" title="All 2 branches covered.">    if (!isOpen()) {</span>
<span class="fc" id="L1184">      throw new ClosedChannelException();</span>
    }
<span class="fc" id="L1186">  }</span>

  /**
   * Throws an IOException if precondition is false.
   *
   * &lt;p&gt;This method should be used in place of Preconditions.checkState in cases where the
   * precondition is derived from the status of the IO operation. That makes it possible to retry
   * the operation by catching IOException.
   */
  private void checkIOPrecondition(boolean precondition, String errorMessage) throws IOException {
<span class="fc bfc" id="L1196" title="All 2 branches covered.">    if (!precondition) {</span>
<span class="fc" id="L1197">      throw new IOException(errorMessage);</span>
    }
<span class="fc" id="L1199">  }</span>

  private static Object lazyToString(Supplier&lt;String&gt; stringSupplier) {
<span class="fc" id="L1202">    return new Object() {</span>
<span class="fc" id="L1203">      private final Supplier&lt;String&gt; toString = Suppliers.memoize(stringSupplier);</span>

      @Override
      public String toString() {
<span class="fc" id="L1207">        return toString.get();</span>
      }
    };
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>